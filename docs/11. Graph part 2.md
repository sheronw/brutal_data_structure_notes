date: 2019-1-14 20:57:54

这一篇文章就是各种奇怪的算法了……但考试中给一个图能画出来算法每一步得到的结果就ok，实在不理解的话，死记硬背其实也是可以的hhh

## Search
以下算法针对indirect graph，用来遍历图中每个点。

### Breadth First Search(BFS)
广度优先搜索。如名字所示，就是把当前所在的vertex周围的vertex都搜索一遍，然后**依次**对它周围的vertex都执行相同的这个操作……
咦，好像可以用队列呀？只要检查完它周围的vertex，然后把它们全加进队列里面，然后从队列里面取出下一个就可以咯？
当然，秉着效率优先的原则，我们要把已经检查过了的vertex进行标记，这样就不用再搜一遍了。

    将开始搜索的vertex（就记作s吧）放入队列q中
    当队列q不为空时：
	    dequeue出来一个vertex u
	    检查是否是我们要找的，是的话就return该vertex
	    将u进行标记
	    for u的所有邻居 v：
		    如果v没有标记：
			    将v加入队列q
	return『无结果』

时间复杂度：O(V+E)
首先所有的vertex都要被enqueue和dequeue一次，所以是O(V)；其次对每个u来说，所有的邻居都要被扫描一遍检查是否有标记（也就是说扫描一遍和u有关系的所有edge），这样每个edge都被扫描了两遍（因为它和两个vertex有关系），所以是O(E)。

[可以看这一篇](https://blog.csdn.net/raphealguo/article/details/7523411)

### Depth First Search(DFS)
深度优先搜索。就是一条路走到黑，走不下去了就退到上一个节点，再换另一条路。
……退回到上一个节点？我们可以用递归或者是栈。
stack的话和广度搜索有点相似：

    将起点s标记，放进栈stack中
    当stack不为空时：
	    peek最上面的元素u（只是peek，不拿出来）
	    检查是否u是我们想要的，是的话就return它
	    在与它相邻的vertices中，看看还有没有没被标记的
	    要是有的话，找一个没被标记的v，将其标记并放到栈里面
	    没有的话，就把u从栈里面拿出来
	return 『无结果』

递归：

    dfs(V,E,u):
	    将u进行标记
	    如果就是我们要找的，结束搜索直接return
	    for u所有的邻居v：
		    如果v没有被标记：
			    dfs(V,E,v)
	dfs(V,E,起点s)

时间复杂度和广度优先搜索一样，也是一个vertex都会至少检查一次，每个edge都会检查两次，也是O(V+E)

## Shortest Paths
以下算法用于weighted graph寻找图中两点间最短路径。

### Dijkstra's Algorithm
这个名字看起来挺奇怪，其实那个j好像不发音，是个荷兰的计算机科学家的姓。这个人名言超级多，忘了听谁说的被誉为是计算机科学界的米兰昆德拉……
跑题了，这个算法利用一个表**d**来记录从出发点**s**到图中每一个点的最短距离（初始值是无穷大），然后不断更新它。
为了能够找到确切的路径，我们又准备了另外一个表**prev**（初始值为空），用来存储路径中该点前面的那个点，当然也要不断更新它，这样就可以从我们找到的终点一路开倒车找回s了。
那么如何不断更新呢？把所有的点都放在一个set里面，然后每次拿出来一个距离最小的（可以用priority queue？）（其实这里用到了一种叫做『贪心』的策略，即既然想要最短路径，那就从最短的开始下手）。
给定任意一点u和它的某个邻居v，如何判定我们找到了新的最小距离呢？如果到u的最小距离加上u与v之间的距离竟然小于到v的最小距离，那么就说明经过u到v距离会更短，那么我们就要把到v的最小距离改成之前那个了……

    for all vertices v in graph G: // 初始化
	    d[v]=infinity
	    prev[v]=NULL
	d[s]=0 // 起点到它本身的距离为零
	while 存在未标记的点:
		u=未标记的点中有最小d[u]的那个
		for all neighbors v of u:
			if d[u]+(u,v)<d[v]:
				d[v]=d[u]+(u,v)
				prev[v]=u
		将u进行标记

来分析一下这个的时间复杂度，while循环里面包着的for循环有点熟悉，往上一翻发现和广度优先搜索如出一辙，所以这一块儿应该是O(E)。剩下的就是while里面包着的找最小d[u]的那个了，之前我们说过可以用priority queue，这个的时间复杂度是O(logn)，剩下的部分是和点（vertices）有关的，因此是O(VlogV)。加起来总的时间复杂度应该是O(VlogV)。

那么输出完整路径的算法为：

	v=我们要找的终点
    while prev[v]!=s:
	    print v
	    v=prev[v]
	print s

悄悄地说一句，这是我们当初期末考试中唯一一个真正考了的关于graph的算法……hhh

### Floyd's Algorithms
dijkstra 的算法虽然快，但有一个问题：当weighted graph中有值为负的edge的时候就用不了了（dijkstra的『贪心』找最短距离的邻居这个策略就行不通了，如果有负edge的话，经过它那里到邻居的距离可能比它的距离还短）。
Floyd呢，运用了『动态规划』的算法思想，如果没记错的话**不管是考试还是lab都不太可能会出现，看不懂也没关系**……
动态规划比较浅显的解释就是这样：准备一个表，然后开始填表，有一些值要事先填好，每一个需要填的值都与已经填好的某些值有固定关系（类似递归）。
之前说到，已经不能用找邻居的方式来解决这个问题了，但我们可以列一张表，把任意两点之间的最短距离都列出来。
和之前的adjacency matrix一样，我们需要一个二维数组来记录两点间最小距离（就叫这张表是memo\[|V|\]\[|V|\]吧）。
首先把base case填好。为了便于更新最小值，把所有值都初始化为无穷大。每一点和自己的距离目前是0。任意两个edge之间的距离，我们先初始化为edge的值本身。
然后我们来找到填表的关系。因为可能会出现负值，所以不能像之前那样只走一遍了。对于这个图中的每一个点k，我们都要考虑是否有可能有**任何两点之间的最短距离(i,j)**会使用(1...k)这些点（就是将所有点都排一下序）。所以对每个点k来说我们都要从头到尾重新把这个表再填一下，看看会不会有更小的值。如果这个最小距离和k根本没关系的话，那么使用(1...k)这些点和使用(1...k-1)这些点的结果是一样的。如果有关系的话，那么最小距离就可以分成两半——使用从(1...k-1)这些点，从i到k的距离加上从k到j的距离。

    momo[][]=new int[V][V]
    for i in range (1,V):
	    for j in range (1,V):
		    if i==j, memo[i][j]=0
		    else, memo[i][j]=infinity
	for edges (u,v) in G:
		memo[u][v]=d(u,v)
	for k from 1 to V:
		for i from 1 to V:
			for j from 1 to V:
				if memo[i][j]>memo[i][k]+memo[k][j]:
					memo[i][j]=memo[i][k]+memo[k][j]

时间复杂度倒是一看便知，三个for循环，O(V<sup>3</sup>)
