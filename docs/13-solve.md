# 排序算法相关题目解析

## 选择最优的算法

对于这个问题，千万不要脱口而出「快排」，而是先询问面试官有什么条件、场景是什么：

- 关于数据：是否部分排序、是各不相同还是允许重复值、数据有多大
- 关于要求：排序是否需要稳定、重点优化最优、最差还是平均时间复杂度？
- 关于系统：和数据相比，内存有多大？

### 主服务器问题

> 一个主服务器负责接收多个发送自副服务器、已经排序好的数据，求主服务器上将所有数据排序的最优算法。

当然可以选快排，但根据条件，数据已经部分排序，因此用归并搜索更好。如果是这样的话，新建一个列表将每个副列表中最小/大的挪进去就可以了，时间复杂度乍一看是 O(n)。

但是，事情没有那么简单。假设副服务器数量为 k，那么时间复杂度为 O(kn)。k 比较小的情况下，这个时间复杂度可以近似于 O(n)，但当服务器数量无限多的时候，比如多于 n，那么可能时间复杂度会变成 O(n<sup>2</sup>)。

如何来优化这一点呢，因为不管怎么说都要把总共 n 个数据放入列表，那么先把 n 放在一旁，对 k 这个系数进行优化。我们原本的方法是将 k 个列表中最小/大的值都遍历一遍，找到最小/大值，时间复杂度为 O(k)，如果需要优化的话，就是找个 O(logk)的找最大最小值的方法，比如最小/大顶堆。但问题是你需要多出 O(k)的空间来做这个顶堆，这样总时间简化到了 O(nlogk)。如果内存不够的话，那就只能继续用 O(kn)那个咯。

当然，因为是服务器与服务器之间的数据传输，你还可以用一些在线算法——因为每次只需要获取副服务器数组中的最大值，如果主服务器不能为归并搜索腾出额外的 O(n)内存，可以让副服务器每次只发送最小/大值，然后储存在 O(k)的内存中。但一旦要加上网络传输，复杂度也就会更高，考虑的问题也更多。

### 加工厂问题

> 一个加工厂监测系统每天会在白天将所有不合格的产品序列号加入一个列表中，在晚上将序列号批处理排序，求最优算法。

这道题其实有些表述不清，需要问清楚：是只有一个列表，还是一天一个列表？我们这里指的是只有一个大的列表，每天往里添加。

既然是一小组数据加入到一个很大的数据中，那么可以考虑插入排序，因为在最好情况（列表已经基本排好序）的情况下，可以近似于 O(n)。但和上一道题目同理，假设一天的不合格产品为 k，那么时间复杂度为 O(kn)，如果有一天残次品特别多，可能就会 O(n<sup>2</sup>)了。

如果想要对这种情况进行优化，可以和上次一样归并排序。先把这 k 个数据给排好，比如用快排吧，就是 O(klogk)，然后归并需要 O(k+n)，所以总的是 O(n+klogk)。当然这个就需要额外的 O(k+n)空间。

### 数据未知问题

> 在内存足够的情况下，对多组未知数据进行排序，并且他们有较大的长度差异，求最优算法。

虽然对于不同的情况有着不同的最优算法，所以最好的办法是分类讨论。比如在 Java 中默认的排序方法是在数据长度小于 10 时用插入算法，其他情况下，因为数据未知，就用万金油的归并和快排。

## 稳定的选择排序

首先声明一下定义。这里指的「稳定」不是指时间复杂度最坏最好平均都差不多，而是假设元素 a，b 一前一后并且 key 相同，那么根据 key 排序之后 a，b 仍然保持一前一后的顺序。

先回顾一下选择排序算法，指的是依次找到数组中最大/小的元素然后与数组前端的元素交换。为了改进变成选择排序，需要至少改动两个地方：第一个是遍历寻找最/大小值时，如果是从前往后搜索，可能先找到的是靠后的元素并且被提前换到了前面，所以要从后往前搜索，确保找到的最大/小值在最前面；还有一个地方比较棘手，就是在交换的时候，前部的元素被交换到了后面，因此可能会失去其顺序。这个的解决方案是将这个元素放在备选元素和已排序元素之间，即使总时间复杂度不便，但这个行为的代价很大，需要 O(n)的时间复杂度将所有后面的数组挪一位放进去。

在实现算法之前，需要解释在选择排序的基础上改动变成稳定的排序算法并不是一个很好的选择（比如插入排序只要在插入时选择在 key 相同的元素之后就可）。还有一个可能的改动方案是使用链表，这样从中间插入只需要 O(1)的时间复杂度。

```javascript
function stableSelectionSort(arr) {
  if (!arr) return arr;
  for (let i = 0; i < arr.length; i++) {
    let min = i;
    for (let j = arr.length - 1; j > i; j--) {
      if (arr[j] <= arr[min] && arr[min] != arr[i]) {
        // need not to swap arr[i]
        min = j;
      }
    }
    if (min != i) {
      // swap
      let temp = arr[i];
      arr[i] = arr[min];
      for (let k = min - 1; k >= i + 1; k--) {
        arr[k + 1] = arr[k];
      }
      arr[i + 1] = arr[i];
    }
  }
  return arr;
}
```

## Multi-key 排序

给定一组代表员工的对象，要求用自带库以姓、名的顺序排序。

```javascript
const Employee = {
    this.surname = "XXX";
    this.givenname = "XX";
}
let arr = [Employee];
const comparator = function(a,b) {
    let ret = a.surname-b.surname;
    return ret==0 ? a.givenname-b.givenname : ret;
}
arr.sort(comparator);
```

## 稳定排序

假设已经有一个不稳定的排序方法`shakySort(arr, comparator)`，要求在不修改排序方法的基础上，实现稳定排序。

因为排序算法只能调用不能改动，所以需要在数据本身上做手脚。一开始想到的是将相同的元素进行区分，比如元素 a，b 一前一后并且 key 相同，那么给 a、b 分别加上 attribute 1、2 进行区分。但显而易见，要把元素相同的值全找出来并逐一标记并不容易，不过研究一下 comparator 的运行机理就可以知道，其实排序没必要从 1 开始连续，只要前面的值比后面的值大就可以。也就是说只要将一整个数组的 index 作为 atribute 就可以对 key 相同的元素进行区分。

以上一题的代码为例：

```javascript
function stableShakySort(arr, comparator) {
  for (let i = 0; i < arr.length; i++) {
    arr[i].index = i;
  }
  const shakyComparator = function (a, b) {
    let ret = comparator(a, b);
    return ret == 0 ? a.index - b.index : ret;
  };
  let sorted = shakySort(arr, shakyComparator);
  for (let e of sorted) {
    delete e.index;
  }
  return sorted;
}
```

## 蛋糕排序

假设有一叠直径不同的蛋糕，有一个可以将上半部分的所有蛋糕倒置的反转器，求讲它们从上到下直径从小到大排序最多需要反转多少次。

这个让我想到了汉诺威塔问题，可以将它分成「将最大的放到最下面」和「将剩下的部分排序」两个步骤。将最大的放到最下面这个好办，把最大的蛋糕及其上方反转过来，使其变成最上面的蛋糕，然后再反转一次变成最下面的蛋糕。这么一个步骤总共反转了两次。假设一共有`n`个蛋糕，那么需要这么处理`n`次。所以是反转`2n`次。

但用几个例子进行推演之后就发现了当`n=1`和`n=2`时应该是递归的 base case，如果蛋糕只有两个的话，最多只需要反转一次（从下小上大变成上大下小），甚至可能不用反转因此在原答案基础上减一；而`n=1`时不用做任何处理，从原答案里面减去`2`。最后结果得总共反转`2n-3`次；当只有一个蛋糕时不需要反转。
