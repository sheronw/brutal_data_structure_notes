date: 2019-1-7

## Basic Terminology
![enter image description here](https://i.loli.net/2019/01/08/5c34127fa2bf6.png)
树，它有一个树干，然后分成很多树枝，树枝再有很多分支（好吧我可能在说废话）。虽然这么说，“树”作为一个数据结构，它通常是倒过来画的，不如说是根更合适hhh
和表栈队列不同的是，树是我们接触的第一个非线性（nonlinear）的数据结构（所以难度会飙升）。
就和之前的linked list一样，树中的每个单元都是一个node。
既然不是线性的，树中的那些nodes是如何联系起来的呢？
近一点说，两个node之间是由edge相连（好像是废话），就是图示里面的那条线。
那宏观一点呢，一般来讲，树干死了基本上树枝也得挂，所以树干比树枝牛逼——你可以看到，树这个结构是有“阶级制度”的。

每棵树最顶上的那个node叫root（根）。
只要一个node在另一个node上面，那么它就是爸爸parent，另外一个就是child儿子。（是的，在lab里面还会看到爷爷和叔伯）
如果一个node没有儿子，那么它就是最low的，叫leaf。
height是**一棵树**从root到某个leaf的最长路径长度。
depth是**一个node**到root的路径长度。

## Binary Tree
这就简单了，binary嘛，每一个node都顶多俩儿子，一个叫left child另一个叫right child（如果有的话）。
![enter image description here](https://i.loli.net/2019/01/08/5c341a504448a.png)

## Tree traversals
因为树不是线性的，所以访问不同node的先后顺序也有很多：

### depth first
其实就是把每个node都当作是某个sub-tree的root然后写递归……下面这三种也只是顺序不太一样而已。而且不觉得这些前缀有些眼熟嘛，就是之前讲的不同运算顺序啊！（可以对比一下想想看hhh？）

#### in-order
爸爸在中间，儿子站两边。
用上面的那个图举例子：D B E A F C

    inorder(root):
	    if root is not NULL:
			inorder(root's left child)
			visit root
			inorder(root's right child)
			
在这里补充一下利用栈来实现的iterate写法（一直往栈里放左儿子直到不能放了为止）：

    inorder(root):
    	    create an enpty stack
	    let pointer point to root
	    while pointer is not NULL or stack is not empty:
	                while pointer is not NULL:
				push pointer to stack
				let pointer be pointer's left child
			pop a node from stack and let pointer point to it
			visit this node
			let pointer point to its right child


#### pre-order
爸爸站最前面，两个儿子站后面。
上图例子：A B D E C F

    preorder(root):
        if root is not NULL:
    		visit root
    		inorder(root's left child)
    		inorder(root's right child)
		
用栈来实现的写法，注意的是每次拿出来的是最后放进去的，所以左右儿子放进去的顺序要颠倒一下……

    preorder(root):
    	create an empty stack
	push root to stack
        while stack is not empty:
    		pop a node from stack and visit it
    		push node's right child to stack
		push node's left child to stack

#### post-order
爸爸殿后，两个儿子打头阵。
上图例子：D E B F C A

    postorder(root):
        if root is not NULL:
    		inorder(root's left child)
    		inorder(root's right child)
    		visit root
		
用栈来实现的写法，类似于inorder，只是需要判断什么时候开始「转向」（访问中间节点），方法是储存上一个访问的节点，如果上一个访问的节点就是当前节点的右儿子（或者为空），说明是时候访问该节点了；不然的话，将右儿子入栈。

    postorder(root):
    	create an empty stack
	let pointer point to root
	let last_pointer be NULL
        while pointer is not NULL or stack is not empty:
    		while pointer is not NULL:
			push pointer to stack
			let pointer point to its left child
		let pointer be the top element in stack(use peek method usually)
		if last_pointer is the right child of pointer or the pointer has no right child:
			visit pointer
			pop an element from stack(discard it)
			let last_pointer be pointer
			let pointer be NULL
		else:
			let pointer be its right child

### breath first
也就是说level first。一层一层来，从左到右。
上图例子：A B C D E F
这个的算法就要用到刚刚讲的队列了：

    create an empty queue
    enqueue root
    while queue is not empty:
    	dequeue a node N
    	visit N
    	if N's left child is not NULL:
    		enqueue N's left child
    	if N's right child is not NULL:
    		enqueue N's right child

## Implementing Binary Trees
这段等学完java再仔细讲。
和linked list一样，都需要一个叫做node的单元，只不过把prev和next换成了left和right而已。
