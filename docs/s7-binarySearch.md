# 二分查找相关题目解析

之前没做过这个类型的题目，感觉小看二分查找这个知识点了，坑还是蛮多的。

## 基本的二分查找

可以用递归也可以用循环遍历，一般来讲做题时用的比较多的是下面这个：

```python
def binarySearch(arr,target):
    l, r = 0, len(arr) # 前闭后开原则
    while l < r: # 搜索至搜索区间为空
        mid = l + (r - l) // 2 # 以闭区间起点为中心进行调整防止溢出
        if arr[mid] < target: # 调整区间，确保区间左侧元素都小于区间内元素
            l = mid + 1
        else: # 调整区间，确保区间右侧元素都大于或等于区间内元素
            r = mid
    return l # 当搜索区间为空时，l与r相等
```

当然，当我们在说二分搜索的时候，针对不同的题目要求，可能指的是这几种情况中的一个：

- 寻找第一个大于或等于 target 的元素
- 寻找最后一个不大于或等于 target 的元素
- 寻找第一个大于 target 的元素
- 寻找最后一个不大于 target 的元素

这四种说法等价于：

- > = target, upper bound
- > = target, lower bound
- > target, upper bound
- > target, lower bound

上面的代码中，因为是确保区间左侧元素都小于区间内元素，所以表达的是第一种情况。如果想要寻找第一个大于或等于 target 的元素，将`if`的条件换成`<=`，即确保区间左侧元素都大于或等于区间内元素。如果想要求 lower bound，虽然也可以前开后闭再写一次，但最好是用`upper bound-1`，这样背一个模板就可以搞定辣。

### Upper Bound 类题目

#### LC704 Binary Search

本题要求返回 target 的座标，不存在则返回-1。

因为模板找的是第一个大于或等于 target 的元素，所以如果 target 不存在，就会返回错误结果。所以可以再加一个判断条件，如果等于目标就返回当前座标，或者在最后查是否边界溢出以及等于 target。最后返回-1 即可。

### LC35 Search Insert Position

本题要求返回 target 座标，不存在就返回 target 应该插入的座标。

显然返回的是第一个大于或等于 target 的元素座标，直接使用模板即可。（不过判断等于目标并返回，也不会错）

### LC34 Find First and Last Position of Element in Sorted Array

本题要求返回 target 的座标范围。比如`[1,1,1]`返回`[0,2]`。如果目标不存在就返回`[-1,-1]`.

如果想要一口气同时找到两个端点其实有点麻烦，所以不如找两次，反正还是 O(logn)。

第一个座标应该是第一个大于或等于 target 的元素，如果不存在就返回-1，和 LC704 相同。第二个座标应该是最后一个不大于 target 的元素，如果不存在同样返回-1。题目要求的区间不是前闭后开，所以要在`<=`模板的基础上-1。

一个需要注意的点是不能再判断条件中发现等于 target 就返回，因为需要找的是边界值。需要放到循环结束后去判断是否越界或不存在。

也可以找到其中一个端点然后向后或者向前找，但最坏情况下时间复杂度为 O(n)，不推荐。

### LC981 Time Based Key-Value Store

带点 OOP 元素的二分查找。set 与 LC35 相同，get 则是找不大于 target 的最后一个元素。不过要判断字典中是否存在该元素等一系列条件。

### LC69 Sqrt(x)

第一个需要「猜」的题目，虽然之后会出现很多。基本上就是从 0 到 x 中不断地选中点，判断该值的平方与 x 的大小关系。

这题要的是开根号结果的 floor，也就是说求的是最后一个不大于目标的元素。

不过如果按照模板实现的话，因为我们将开区间范围设定为 x，所以需要将 1（它的根号还是它自己，取中点永远得不到）。

## 参考资料

> [二分查找有几种写法？它们的区别是什么？ - Jason Li 的回答 - 知乎](https://www.zhihu.com/question/36132386/answer/530313852)
